[09 February]
afterをevalで起動するというのは，
specificなjobsetクラスの仕様としてはありかも
入力ファイルテンプレートとn次元の探索空間から，入力ファイル（および入力ファイル名）を作る
このシンタックスシュガーをかけるか？
開発コストの問題
中島先生の例
Perlの式を埋めこんだテンプレート
ログがわらわら→大量の出力: 出力の最後の行の時間だけほしい
というのが簡単に書きたい


[08/11/05]
;;; built-in class (C++風)
class Job
{
  id = generate_unique_integer_id();
  exec = "";
  args = ();
  env = ();
  stdout = "<job_name>.out";
  stderr = "<job_name>.err";
  stderr_merge_p = false;
  NQS_queue = "";
  NQS_qsub_args = ();
  exit_code;
  ...and more...
  /* methods */
  new (...) {...}             // コンストラクタ
  main ();                    // user-defined．staticメソッド．entry-point．
  before () {};               // extended by user
  do () {       // mainで明示的に呼び出す．これ自体は拡張はしない？
     invoke_all_before();
     Execute "exec" with the argumemts "args" in the environments "envs".
     After the execution is finished (and before invoking "after"),
     its exit code is set to "exit_code".
     spawn invoke_all_after();
  }
  synchronized after () {};   // extended by user
}

;;; （例1）単にjobを100個投げる．直接実装．
てゆーか，APL_PARAM1って実行時引数を環境変数渡ししてただけ？
class My_job : Job
{
  /* default values（全ジョブ共通の情報） */
  exec = "./sample";
  NQS_queue = "queue1";   // argument of qsub -q option
  /* 追加field */
  p1;
  ;;
  new (p1) { super(); $p1 = $self->p1; }
  main () {
    foreach $i(1 .. 100)
      new($i)->do();
  }
  before () {
    $self->args=($p1);
  }
  after () {
    print "Job $self->p1 terminated with exit code $self->exit_code."
    if ($p == 50) { ... }
  }
}

;;; (例2) jobをnjob個 順に投げ，全部終わったらメッセージを表示する．
/* Library class */
class Loop_job : Job
{
  /* 追加field */
  static njob;               // staticのあるものは全ジョブの共有情報
  private static submitted;
  private static finished;
  after_all ();              // user-defined
  /* extended methods */
  main () {
    while ($submitted < $njob)
      new()->do();
  }
  after () {
    if (++$finished >= $njob) after_all();
  }
}

/* User script */
class My_loop_job : Loop_job
{
  /* default values（全ジョブ共通の情報） */
  exec = "./sample";
  NQS_queue = "queue1";   // argument of qsub -q option
  njob = 100;
  /* extended methods */
  before () {
    $self->args = ($submitted+1);
  }
  after () {
    print "Job $self->p1 terminated with exit code $self->exit_code."
    if ($self->args[0] == 50) { ... }
  }
  after_all () {
    print "All jobs finished!"
  }
}

/*
before, do, afterの実行順序は
(1) 親クラスのbefore, ..., 子クラスのbefore,
(2) ジョブ投入
(3) 子クラスのafter, ..., 親クラスのafter
*/

;;; (例3) jobをnjob個 順に投げ，全部終わったらメッセージを表示する．
;;;       同時投入job数を max_concurrency個に制限する
;;; Semaphoreを使いたくなければ，beforeとafterをまとめてserializedするのも手だが
;;; その場合，after中でdo()が実行されるとデッドロック
/* Library class */
class Restrict_job : Loop_job
{
  static max_concurrency;
  static private semaphore = Semaphore->new($max_concurrency);
  /* extended methods */
  before () {
    $semaohre->aquire();
  }
  after () {
    $semaphore->release();
  }
}

/* User script */
class My_loop_restrict_job : Loop_job, Restrict_job
{
  /* default values（全ジョブ共通の情報） */
  exec = "./sample";
  NQS_queue = "queue1";   // argument of qsub -q option
  njob = 100;
  max_concurrency = 10;
  /* extended methods */
  before () {
    $self->args = ($submitted+1);
  }
  after () {
    print "Job $self->p1 terminated with exit code $self->exit_code."
    if ($self->args[0] == 50) { ... }
  }
  after_all () {
    print "All jobs finished!"
  }
}

;;; オブジェクト指向に見えるのがいやなら
package My_loop_restrict_job(Loop_job, Restrict_job);

/* default values（全ジョブ共通の情報） */
exec = "./sample";
NQS_queue = "queue1";   // argument of qsub -q option
njob = 100;
max_concurrency = 10;

/* extended methods */
before () {
  $self->args = ($submitted+1);
}
after () {
  print "Job $self->p1 terminated with exit code $self->exit_code."
  if ($self->args[0] == 50) { ... }
}
after_all () {
  print "All jobs finished!"
}

;;; (例4) ジョブグループで待ち合わせ
;;; 正しく動くためには，afterの起動がmain終了後である必要がある
/* Library Class */
class Jobgroup : Job
{
  static hash = {};     // hash table: group-id => job-list
  /* methods */
  gid ();               // user-defined. ジョブに対応するグループ名を返す
  after_group (gid);    // user-defined. ジョブグループが終了したときに起動．
  before () { push ($self, %hash{gid()}) }
  after () {
    my (@jlist) = %hash(gid());
    remove ($self, @jlist);
    if ( empty(@jlist) } after_group (gid());
  }
}

/* user program */
;;; 奇数番目/偶数番目 のジョブが全て終了するのを待ち合わせ
class Myjobgroup : Loopjob, Jobgroup
{
  exec = "./sample";
  NQS_queue = "queue1";   // argument of qsub -q option
  njob = 100;
  p;
  new () { super(); $self->p = $submitted+1 }
  before () { $self->args = ($self->p) };
  gid () {
    if ( $self->p % 2 == 0 ) "even"
    else "odd"
  }
  after_gruop (name) {
    if ($name == "even") { print "Job group 'even' finished." }
    else if ($name == "odd" { print "Job gruop 'odd' finished." }
    else error();
  }
}
  
* 難しい問題
  - 複数のモジュールを適用したときの安全性
    - よくある多重継承問題
    - LaTeXでも時々問題になるが，こちらは適当にやっている感じ
    - 自動判定が理想

[08/10/24]
* 投入してしまったjobを，必要ないとわかれば殺す話
  -> 例外処理？
* fault tolerant
  - originalのPJO

[08/10/08]
* mainスレッドとsubスレッドのconcurrency?
* 「同時activeジョブ数を制限するための」jobクラスをライブラリ的に用意
* 待ち合わせを関数化
  - 各ジョブに対してのみ待ち合わせるのではなく，もっと柔軟な条件に対するfinalizerが書けるようにする
  - 複数ヒットしたときにどうなるかのsemanticsを明確する必要がある（orまち）
  - and待ち
  - jobのunique_id
* どこかから先ではオブジェクト指向的に書いてもらうしかない（どこ？）
  - level 0（ちょっとだけ何かしたい人）,1（?，待ち合わせの種類は決められた中から．．．）,2（実装 の情報も使う),3
* とりあえずジョブの依存グラフを作っておいて，後から投入する（記述もそれぞれ別にする）？
  - 動的にグラフが変わる場合どうするか
  - デフォルトではなさそう（直観的でない？）
* jobを投げたことにする，とかは実行時のオプションで

=================
案（オブジェクト指向版）
foreach $p1(1 .. 100) {
  $ENV{“APL_PARAM1”} = $p1; $njob=0;
  {
    wait_for ($njob<10);
    $njob++;
    my ($job) = new_job (ex_job); $job.exec = “./sample”; $job.env = “APL_PARAM1”);
    $job.attribute_NQS_queue = “queue1”;
    $job.parameter = $p1;
    ;; ジョブ投入のみ計算ノードで実行． $rcにはexit_codeが何らかの方法で渡るようにする
    (with_job job
      ;; do_job本体 + when節 相当
      ;; ここ以下（with_job本体）は，管理ノード内のforkされた別スレッド
      ;; がジョブの終了を待って実行する．
      ;; 本スレッドはそのまま先（ここでは次のiteration）に進む
      $njob--;
    )
    print “Job $job.parameter terminated with exit code $job.rc."
  )
}
==================
案（クロージャ共有版）
foreach $p1(1 .. 10) {
  $ENV{"APL_PARAM1"} = $p1;
  {
    my ($parameter) = $p1;
    ;; ここで指定されたジョブ投入のみ計算ノードで実行
    ;; $rcにはexit_codeが何らかの方法で渡るようにする
    (with_job (($rc "./sample" :env "APL_PARAM1")
               :attribute ((NQS.queue "queue01")))
      ;; ここ以下（with_job本体）は，forkされた別スレッド
      ;; がジョブの終了を待って実行する．
      ;; 本スレッドはそのまま先（ここでは次のiteration）に進む
      if (0 != $rc) {
          PJO::abort "job executes failed\n";
      }
      ;; ここにwhen節相当
      if (1 == $parameter) {
        print "JOB 1 TERMINATED NORMALLY."
      } else {
        print "job $parameter terminated normally."
      }
    ) ; with_jobおわり
  }
}
=================

[08/09/02]
10/8 13:00
when節をなんとかする（ぜんぜん直観的じゃない）
job投入時，結果の情報を使えるように

top {{
  foreach $p1(1 .. 10) {
    $ENV{"APL_PARAM1"} = $p1;
    do_job {{ parameter=$p1 }} {{   // ノードで実行される
        attribute {{ NQS.queue=“queue01”}}
        $rc = system("./sample", $ENV{"APL_PARAM1"});
        if (0 != $rc) {
            PJO::abort "job executes failed\n";
        }
    }}
  }
}} 

when {{ {{ parameter=$x }} }} {{
    print "job parameter=$x terminates normally.\n";
}}
