\documentclass[report]{jsbook}

\usepackage{alltt,tascmac}

\title{Xcrypt マニュアル}
\author{京大中島研e-scienceグループ}

\begin{document}
\maketitle
\tableofcontents

\paragraph{メモ}
定義すべき用語
ジョブスレッド

重要

Daniel Muey 氏の Recursive.pm を使用している．ライセンス的には問題ないは
ず．

\part{総論}
\chapter{機能}

通常，ある一つの大きな処理を行うには，その処理を小分け（ジョブと呼ぶ）
にし，それらの処理をジョブスケジューラに依頼する．具体的には，
\begin{enumerate}
\item ジョブスケジューラが理解できるスクリプトを作成し，
\item そのスクリプトをジョブスケジューラに渡し，
\item ジョブスケジューラが返す結果からまた別のスクリプトを作成し，それ
      をジョブスケジューラに渡す，
\end{enumerate}
という一連の操作を繰り返すというものである．

しかし，この方法は処理の繰り返しごとに人手による介入を要し，作業効率が
悪い．そこで，人手で行うところを適当なスクリプト言語により記述すること
で自動実行を実現することが考えられる．Xcrypt はそのスクリプト言語とし
て Perl を採用し，パラメタ指定によるジョブの生成や投入を Perl の関数と
して提供することで，ユーザがジョブ処理を容易に行うことを補助する．

TODO: サーチアルゴリズム等のアルゴリズムモジュールの提供についても記述
する．

\chapter{Xcrypt スクリプトの記述}

Xcrypt は Perl の拡張である．よって，全ての Perl スクリプトは Xcryptス
クリプトである．しかし，Xcrypt はジョブに関する操作の補助を行うものと考
えられ，Xcrypt スクリプトは典型的には以下の順に記述される．

\def\usemodule{モジュールに関する記述}
\def\defjobdefhash{ジョブ定義ハッシュに関する記述}
\def\operation{ジョブ処理に関する記述}

\begin{enumerate}
 \item \usemodule
 \item \defjobdefhash
 \item \operation
\end{enumerate}

\section{\usemodule}

利用可能なモジュールにはコアモジュールとそれ以外のモジュールの二種類が
ある．コアモジュールは
\begin{boxnote}
\begin{alltt}
use base qw(core);
\end{alltt}
\end{boxnote}
\noindent
と記述して読み込む．コアモジュール以外（例えば\texttt{dry.pm}）に関して
は，
\begin{boxnote}
\begin{alltt}
use base qw(dry core);
\end{alltt}
\end{boxnote}
\noindent
と記述して読み込む．利用可能なモジュールに関しては\ref{chapmodule}章で
述べる．

\section{\defjobdefhash}

Xcrypt ではジョブはハッシュ（ジョブハッシュと呼ぶ）で実現されている．ジョ
ブを定義するにあたり，ハッシュ自身を記述してもよいが，ジョブ定義ハッシュ
と呼ばれるハッシュを記述すれば，ジョブを生成する際，さらにパラメタを与
えることで多数のジョブを一度に生成できる．例えば，
\begin{boxnote}
\begin{alltt}
%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => 'plasma.inp',
    'arg1' => '100',
    'copieddir0' => 'forcopieddir',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @\$-g gh10034'
);
\end{alltt}
\end{boxnote}
\noindent
と記述する．定義可能なジョブ定義ハッシュのキーに関しては
\ref{chapjobdefhash}章で述べる．

\section{\operation}

通常，人手で行う処理で，今回，Xcrypt に行わせたい処理について記述す
る．Xcrypt で利用可能な関数については\ref{chapfun}章で述べる．

\section{記述例}\label{secscriptexample}

本章で前節までの説明を踏まえたスクリプト記述例を以下に示す．

\begin{boxnote}
\begin{alltt}
use limit;

\$limit::smph=Thread::Semaphore->new(10);

%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => 'plasma.inp',
    'arg1' => '100',
    'copieddir0' => 'forcopieddir',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @\$-g gh10034'
);

my @jobs = &prepare(%xyz, 'arg1s' => [2,4]);
my @thrds = &submit(@jobs);
my @results  = &sync(@thrds);

foreach (@results) \{ print \$\_->{stdout} , "\verb?\?n"; \}
\end{alltt}
\end{boxnote}

\chapter{ジョブ処理の流れ}

実際のジョブ処理の流れについて概観する．

\section{実行方法}

環境変数 \texttt{XCRYPT} を Xcrypt をインストールしたディレクトリで定義
する（ここでは \texttt{/usr/share/xcrypt} と仮定する）．シェルが bash
なら，
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}

作業ディレクトリに移動する（ここでは \texttt{\$HOME/wd} とする）．
\begin{screen}
\texttt{\$ cd \$HOME/e-science/wd}
\end{screen}

Xcrypt スクリプト（\ref{secscriptexample}節参照）を作成する（ここでは
sample.xcr とする）．

実行する．
\begin{screen}
\texttt{\$ \$XCRYPT/xcrypt sample.xcr}
\end{screen}

\section{作成される物}

Xcrypt を実行した際，作業ディレクトリ以下に作成される物について説明する．

\subsection*{ディレクトリ}

Xcrypt はジョブごとにディレクトリ（ジョブ作業ディレクトリと呼ぶ）を作成
する．ディレクトリの名前はジョブハッシュの\texttt{id}キーの値である．
ジョブ処理はジョブ作業ディレクトリで行われる．

\subsection*{ジョブリンク・ジョブファイル}

ジョブ作業ディレクトリからジョブハッシュの
\texttt{linkedfile0,...,linkedfile255}キーの値で指定されているファイル
へシンボリックリンクを張り，\texttt{copiedfile0,...,copiedfile255}キー
の値で指定されている作業ディレクトリ中のファイルのコピーをジョブ作業ディ
レクトリに作成する．

\subsection*{\texttt{nqs.sh}}

ジョブスケジューラが NQS である際，NQS に渡されるスクリプトである．

\subsection*{\texttt{sge.sh}}

ジョブスケジューラが Sun Grid Engine である際，Sun Grid Engine に渡され
るスクリプトである．

\subsection*{\texttt{request\_id}}

Xcrypt によるジョブの投入に対し，ジョブスケジューラが返すジョブのリクエ
ストIDを格納する．

\subsection*{\texttt{stdout}}

ジョブの実行コマンドの標準出力が格納される．ジョブハッシュの
\texttt{stdofile}キーの値が指定されている場合，その値のファイル名で作成
される．

\subsection*{\texttt{stderr}}

ジョブの実行コマンドの標準エラー出力が格納される．ジョブハッシュの
\texttt{stdefile}キーの値が指定されている場合，その値のファイル名で作成
される．

\part{各論}
\chapter{モジュール}\label{chapmodule}

\section{\texttt{core}（コア）}

コアモジュールを全て読み込む．

\section{\texttt{dry}}

Xcrypt をドライモード（実行コマンドなしで）で動作させることができる．

Xcrypt スクリプトに
\begin{boxnote}
\begin{alltt}
\$dry::dry = 1;
\end{alltt}
\end{boxnote}
\noindent
と記述することで Xcrypt がドライモードで動作する．また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．

\if0
\section{\texttt{function}}

頻繁に使用される関数を定義している．

\section{\texttt{UI}}

組込み関数を提供する．

Xcrypt はジョブ作業ディレクトリ以下にジョブ定義ハッシュにおける
\texttt{id,arg0,\ldots,arg255}を\texttt{\$separation\_symbol}で区切っ
た名前のディレクトリを作成する．\texttt{\$separation\_symbol}のデフォ
ルト値は「!」である．「-」に変えたい場合は，
\begin{boxnote}
\begin{alltt}
\texttt{\$jobsched::separation\_symbol = '-';}
\end{alltt}
\end{boxnote}
とする．

\fi

\section{\texttt{graph}（コア）}

ジョブの実行を制御することで，ジョブの実行に関するグラフ構造を実現す
る．ジョブは，ハッシュの\texttt{predecessor}キーの値であるところのジョ
ブたちの処理が終わるまで投入されず，処理後はハッシュの
\texttt{successor}キーの値であるところのジョブたちを生成する．

\section{\texttt{limit}（コア）}

一度に投入されるジョブの数の上限を指定する．

\begin{boxnote}
\begin{alltt}
\$limit::smph=Thread::Semaphore->new(100);
\end{alltt}
\end{boxnote}

\section{\texttt{jobsched}（コア）}

ジョブスケジューラとのインターフェイスである．

（注）SGE の qstat について考えていないので SGE では動作しない．

ジョブスケジューラが Sun Grid Engine の場合は，Xcrypt スクリプトに
\begin{boxnote}
\begin{alltt}
\$jobsched::sge = 1;
\end{alltt}
\end{boxnote}
と記述することで Sun Grid Engine に対して Xcrypt を正常に動作させること
ができる．デフォルト値は$0$である．
\begin{screen}
\texttt{\$ xcrypt -s sample.xcr}
\end{screen}
とオプションつきで実行することと同義である．


\chapter{ジョブ定義ハッシュ}\label{chapjobdefhash}

ジョブ定義ハッシュにおいて利用可能なキーについて紹介する．

\section{\texttt{id}}

\section{\texttt{exe}}

実行されるジョブの実行コマンドを記述する．後述の\texttt{arg0,...,arg255}とともに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{arg0,...,arg255}}

実行されるジョブの実行コマンドの引数を記述する．前述の\texttt{exe}とと
もに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{linkedfile0,...,linkedfile255}}

この値のリンク名でジョブ作業ディレクトリから作業ディレクトリのファイル
へシンボリックリンクを張る．

\section{\texttt{copiedfile0,...,copiedfile255}}

この値のファイル名でジョブ作業ディレクトリから作業ディレクトリにコピー
をつくる．

\section{\texttt{stdofile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準出力を格納
する．空の場合は「stdout」というファイル名になる．

\section{\texttt{stdefile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準エラー出力
を格納する．空の場合は「stderr」というファイル名になる．

\section{\texttt{ofile}}

実行プログラムの出力ファイルを記述する．

\section{\texttt{odelimiter}}

実行プログラムの出力ファイルの行を区切る際の区切り文字を指定する．

\section{\texttt{ocolumn}}

実行プログラムの出力ファイルの列を指定する．

\section{\texttt{queue}}

実行するジョブを投入するキューの名前を記述する．

\section{\texttt{cpu}}

使用するコア数を指定する．

\section{\texttt{proc}}

使用するプロセス数を指定する．

\section{\texttt{option}}

ジョブスケジューラのオプションを記述する．

\chapter{組込み関数}\label{chapfun}

Xcrypt で利用可能な組込み関数のうち，Perl の組込み関数でないものについ
て紹介する．

\def\format{書式}
\def\example{記述例}
\def\advanced{発展}


\section{\texttt{prepare}}

ジョブ定義ハッシュとパラメタを受け取り，適当なジョブリファレンスの配列
を返す．特に，ジョブの\texttt{id}は後述の\texttt{range0,...,range255}
により生成される．

\subsection{\format}

\begin{boxnote}
\begin{alltt}
prepare(ジョブ定義ハッシュ[,'range0' => リファレンス]
                      ...[,'range255' => リファレンス]
                         [,'ジョブ定義ハッシュキーs' => リファレンス]
                      ...[,'ジョブ定義ハッシュキーs' => リファレンス]);
\end{alltt}
\end{boxnote}

ただし，「ジョブ定義ハッシュキーs」はジョブ定義ハッシュキー
（\texttt{arg0}等）の語尾に\texttt{s}をつけ加えたもの
（\texttt{arg0s}等）を意味するものとする．

\subsection{\example}

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0s' => [10,20]);
\end{alltt}
\end{boxnote}

これは以下と同義である．

\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, ['id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10']);
push(@jobs, ['id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20']);
\end{alltt}
\end{boxnote}

宣言的に書くこともできる．

\begin{boxnote}
\begin{alltt}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo',
    'arg0s' => [10,20]
);
prepare(%abc);
\end{alltt}
\end{boxnote}

ジョブ定義ハッシュとパラメタを分けて書くこともできる．

\begin{boxnote}
\begin{alltt}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
prepare(%abc, 'arg0s' => [10,20]);
\end{alltt}
\end{boxnote}

\texttt{range0}と関数リファレンスを使うことでさまざまなパラメタでジョブ
を生成することができる．例えば，
\begin{boxnote}
\begin{alltt}
@jobs = prepare(%abc, 'range0' => [0..99], 'arg0s' => sub \{ 2 * $_[0] \});
\end{alltt}
\end{boxnote}
は\texttt{prepare(\%abc, 0), prepare(\%abc, 2),..., prepare(\%abc,
198)}を順番に行ったものと同義である．


\subsection{\advanced}

パラメタは複数書くことができる．複数パラメタの配列の頭からジョブは生成
される．例えば，

\begin{boxnote}
\begin{alltt}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'arg0s' => [0,1], 'arg1s' => [2,3]);
\end{alltt}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, ['id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '0', 'arg1' => '2']);
push(@jobs, ['id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '1', 'arg1' => '3']);
\end{alltt}
\end{boxnote}

\texttt{range0}等と関数リファレンスを使うことでパラメタをかけ合わせてジョ
ブを生成することができる．例えば，
\begin{boxnote}
\begin{alltt}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'range0' => [0,1], 'range1' => [2,4],
                'arg0s' => sub \{ $_[0] + $_[1] \});
\end{alltt}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, ['id' => 'xyz_2', 'exe' => './kempo', 'arg0' => '2']);
push(@jobs, ['id' => 'xyz_4', 'exe' => './kempo', 'arg0' => '4']);
push(@jobs, ['id' => 'xyz_3', 'exe' => './kempo', 'arg0' => '3']);
push(@jobs, ['id' => 'xyz_5', 'exe' => './kempo', 'arg0' => '5']);
\end{alltt}
\end{boxnote}


\section{\texttt{submit}}

ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブスケジューラからジョブスレッドを受け取り，それらの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{alltt}
submit(ジョブリファレンスの配列);
\end{alltt}
\end{boxnote}

\subsection{\example}

典型的には\texttt{prepare}の返り値を引数にとる．

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0s' => [10,20]);
submit(@jobs);
\end{alltt}
\end{boxnote}

自力でジョブリファレンスの配列を書いてもよい．

\begin{boxnote}
\begin{alltt}
submit(\{'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10'\},
       \{'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20'\});
\end{alltt}
\end{boxnote}

\section{\texttt{sync}}

ジョブスレッドの配列を受け取り，ジョブ処理後のジョブリファレンスの配列
を返す．

\subsection{\format}

\begin{boxnote}
\begin{alltt}
sync(ジョブスレッドの配列);
\end{alltt}
\end{boxnote}

\subsection{\example}

典型的には\texttt{submit}の返り値を引数にとる．

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0s' => [10,20]);
@thrds = submit(@jobs);
sync(@thrds);
\end{alltt}
\end{boxnote}

\section{\texttt{prepare\_submit\_sync}}

\texttt{prepare}，\texttt{submit}，\texttt{sync}を順に行う．\format は
\texttt{prepare}に準ずる．

\section{\texttt{prepare\_submit}}

\texttt{prepare}，\texttt{submit}を順に行う．\format は
\texttt{prepare}に準ずる．

\section{\texttt{submit\_sync}}

\texttt{submit}，\texttt{sync}を順に行う．\format は\texttt{submit}に準
ずる．


\section{\texttt{pickup}}

ファイル名と区切り文字を受け取り，ファイルの先頭行を区切り文字で分割
し，それらからなる配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{alltt}
pickup(ファイル名，区切り文字);
\end{alltt}
\end{boxnote}

\section{\texttt{repickup}}

ジョブハッシュリファレンスの配列を受け取り，\texttt{ofile}キーの値であ
るところのファイルの先頭行を\texttt{odelimiter}キーの値であるところの区
切り文字で区切った際の\texttt{ocolumn}キーの値であるところの数番目の列
からなる配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{alltt}
repickup(ジョブハッシュリファレンスの配列);
\end{alltt}
\end{boxnote}

\end{document}
