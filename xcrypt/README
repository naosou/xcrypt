内輪向け解説

* 重要

constructor.pm に exit_cond に関するバグあり．
exit_cond に必要性があるか？
直すにしてもどのように直すべきか？
のどちらも不明．

* 実行方法

環境変数 XCRYPT を ${HOME}/e-science/xcrypt とかにする．
移動する（$ cd ${HOME}/e-science/${USERNAME}）．
xcrypt スクリプト（例えば hoge.xcr）を作成する．
実行する（$ {XCRYPT}/xcrypt hoge.xcr）．

* 概要

NQS スクリプト（nqs.sh）を作成し，それを NQS に渡し（$ qsub nqs.sh），
NQS が返す結果からまた別の NQS スクリプトを作成し，それを NQS に渡
し……，という一連の操作を，perl スクリプト user.pl を作成し，それを
xcrypt に渡す（$ xcrypt sample.pl）だけで済むようにするモジュール群である．

ライトユーザ向けに，ジョブレベルでなく，ジョブセットレベルの記述もサポー
トしている．

* 実装

NQS スクリプト一つの作成をスレッド一つで行う．

モジュールにはコアモジュールと汎用目的モジュールとの二種類ある．

コアモジュールは new start before after という関数をのみを持つことがで
きる．これらの関数はこの順番で呼び出される仮定の下で書かれている．

「呼び出す関数 -> 呼び出される関数」と書くことにすると，
1.pm の start -> ... -> n.pm の start ->
top.pm の start ->
1.pm の before -> ... -> n.pm の before
であり，さらに，
top.pm の start ->
n.pm の after -> ... -> 1.pm の after
である．

現在のコアモジュール間の継承関係は，子から親へ向かって constructor.pm
successor.pm dry.pm predecessor.pm limit.pm top.pm である．

汎用目的モジュールは現在 UI.pm function.pm jobsched.pm である．

** xcrypt

ユーザはモジュール群で処理されるフィールドとその値の組となるハッシュを
記述し，そのリファレンスを id と同名のスカラ変数で定義する．

** constructor.pm

trigger.pl で定義されたハッシュリファレンスからジョブを生成する．

オブジェクトの exit_cond と trace から処理を続けるかどうかを判定する．
続ける場合は change_arg で arg を更新した別オブジェクト（その id は元オ
ブジェクトの id の後ろに 0 を付加したもの）を生成し，その処理を行う．

** successor.pm

successor から別オブジェクトを生成する．ただし successor が空の場合は出
力列を traces.log に書き出して終了する．

** dry.pm

./trigger --dry でユーザ定義のオブジェクトのフィールド値を適当に上書き
する．

** predecessor.pm

pjo_inventory_{watch,write}.pl にジョブの処理を終了を判定してもらい，そ
の確認ができるまでジョブの生成を待つ．

** limit.pm

作成されて処理されるのを待っている NQS スクリプトの数をスレッドにまたが
る変数の値で制御する．

** top.pm

関数 before を呼び出すことで前処理をし，NQS スクリプトを作成し，それを
qsub に渡し（ジョブ管理をするモジュール jobsched.pm 中の関数を呼び出す
ことで実現している），関数 after を呼び出すことで後処理をする．

** UI.pm

ユーザがオペレーションとして利用する関数を定義している．

** function.pm

ユーザがデータとして利用する関数を定義している．

** jobsched.pm

pjo_inventory_{watch,write}.pl と連携してジョブ管理を行う．